
#include <iostream>
#include <boost/thread/thread.hpp>
#include <pcl/common/common_headers.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/console/parse.h>
#include <pcl/io/ply_io.h>
#include <pcl/point_types.h>
#include <limits>
#include <vector>
#include "lib/VoxelGrid.cpp"
#include "lib/Pooling.cpp"
#include "lib/Convolution.cpp"
#include "lib/OFFReader.hpp"

using namespace std;

void waitForViewer(boost::shared_ptr<pcl::visualization::PCLVisualizer>  viewer0)
{
	while(!viewer0->wasStopped())
	{
		viewer0->spinOnce(100);
		boost::this_thread::sleep(boost::posix_time::microseconds(100000));
	}// */
}

boost::shared_ptr<pcl::visualization::PCLVisualizer> visualizePC(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr, string id)
{
	boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer0 (new pcl::visualization::PCLVisualizer (id));
	viewer0->setBackgroundColor (0, 0, 0);
	viewer0->addPointCloud<pcl::PointXYZ>(cloud_ptr, "Nube");
	viewer0->initCameraParameters ();
	return viewer0;
}

boost::shared_ptr<pcl::visualization::PCLVisualizer> visualizeCube(Cube pooled1, string id)
{
	boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer2 (new pcl::visualization::PCLVisualizer (id));
	viewer2->setBackgroundColor (0, 0, 0);

	for(int i = 0; i < pooled1.getSideSize(); i++)
	{
		for(int j = 0; j < pooled1.getSideSize(); j++)
		{
			for(int k = 0; k < pooled1.getSideSize(); k++)
			{
				if( pooled1.get(i,j,k) > 0)
				{
					std::string iS= std::to_string(i);
					std::string jS= std::to_string(j);
					std::string kS= std::to_string(k);
					std::string name = "cubei"+iS+"j"+jS+"k"+kS;

					// Esto escala valores de [0,maxDensity] -> [0,1]. Pero es posible que hayan valores negativos. ARREGLAR !!
					viewer2->addCube (i, i+1, j, j+1, k, k+1,((float)pooled1.get(i,j,k)/(float)pooled1.getMaxDensity()), 1, 1, name);// *//*
				}
			}
		}
	} 
	viewer2->initCameraParameters (); // */ 
	return viewer2;
}








int main ()
{
	// Crea una nube vacía sin color
    pcl::PointCloud<pcl::PointXYZ> cloud;

	// Lee los puntos de un fichero ply
	pcl::PLYReader ply_reader; 
	if(ply_reader.read("../models/detergent.ply", cloud) < 0) { 
	   std::cout << "Error while reading the .ply file" << std::endl; 
	   return (0);
	}
	// Puntero a la nube de puntos
	pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(&cloud) ;
    
	// Obtenemos la matriz 3D con las densidades
	// en función del voxel grid que configuramos
	double voxelGridSize = 0.3;
	double leafSize = 0.015;
	VoxelGrid vGrid;
	vGrid.setLeafSize(leafSize);
	vGrid.setVoxelGridSize(voxelGridSize);
	Cube cubeInput = vGrid.filter(cloud_ptr);
	int n = (int)(vGrid.getVoxelGridSize()/vGrid.getLeafSize()); // *****************


	// Obtenemos el resultado de aplicar UN SOLO filtro a cubeInput. 
	// Como sabemos, un filtro resalta una característica
	// por lo que en un uso real en una CNN se deben aplicar N filtros
	// en una sola capa de convolucion
	int regionSizeC = 5;
	int stride = 1;
	Convolution conv1(regionSizeC);
	conv1.setStride(stride);
	Cube convolved1 = conv1.filter(cubeInput);


	// Obtenemos el resultado de hacer el pooling
	// al resultado de la convolucion
	int regionSizeP = 2;
	Pooling pool1;
	pool1.setRegionSize(regionSizeP);
	Cube pooled1 = pool1.filter(convolved1); // *************************************
    cout<<"paso1"<<endl;



	boost::shared_ptr<pcl::visualization::PCLVisualizer> visu0= visualizePC(cloud_ptr, "pointcloud");
    cout<<"paso1"<<endl;
	boost::shared_ptr<pcl::visualization::PCLVisualizer> visu1= visualizeCube(cubeInput, "input");
	boost::shared_ptr<pcl::visualization::PCLVisualizer> visu2= visualizeCube(convolved1, "conv1");
	boost::shared_ptr<pcl::visualization::PCLVisualizer> visu3= visualizeCube(pooled1, "pool1");
	waitForViewer(visu0);



	return (0);
}
